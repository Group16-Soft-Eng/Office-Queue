
//at boot, server has zero counter, when a counter turns on, send a request to the server to register, sending its id and its services
json counter_officer
{
    id: "fghjk"
    services : [
        1,2,4
    ]
}
//call to keep_alive a counter, if time expire, server remove the counter, optional
json keep_alive_officer
{
    id : "$id"
}

//json ticket
json new_ticket
{
    id_ticket : "id_t" //probably 
}

//json for sending next_customer data from server to officer
json next_customer_json
{
    id_ticket : "id_t",
    service_type : "service"
}
//officer complete the ticket and sends ticket information to the server
json send_ticket_done
{
    id_ticket : "id_t",
    id_counter : "id_c",
    service_type : "id_s",
    date : "date"
}

json queue{
    service_type: "id_s",
    ticket_list : [1,2,3,4 ...],
    avg_service_time : UTC_seconds
}
//array or list of queue 

//list queue, struct with multiple queue based on service type, list_officer has an id and an array of services offered,
//list_services maybe a simple enum with the service type (1,2,3 ...)
list_queue, list_officer, list_services

//this are just a simple api call, 
get get_ticket() -> new_ticket
post register_counter(counter_register)
put keep_alive(json(keep_alive_counter)) //optional, probably not gonna implement
get next_Customer() -> next_customer_json
post complete_ticket(send_ticket_done)


basic flowchart of counter :
next_customer -> officer does his things -> 
complete ticket, prepare the json and send to the server the info about completed ticket-> server receives the c_t and insert in the db


unique table of the db is a structure like send_ticket_done json